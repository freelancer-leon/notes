# Runtime locking correctness validator

## 递归读锁：
* 文档的剩余部分试图证明某种类型的循环（cycle）等同于死锁的可能性。
* 锁有三种类型：
  * 写者（即独占锁，如 `spin_lock()` 或 `write_lock()`）
  * 非递归读者（即共享锁，如 `down_read()`）
  * 递归读者（递归共享锁，如 `rcu_read_lock()`）。
* 在文档的其余部分，我们使用以下符号来表示这些锁：
  * `W` 或 `E`：代表写者（独占锁）
  * `r`：代表非递归读者
  * `R`：代表递归读者
  * `S`：代表所有读者（非递归 + 递归），因为两者都是共享锁
  * `N`：代表写者和非递归读者，因为两者都不可递归
* 显然，`N` 是 “`r` 或 `W`”，`S` 是“`r` 或 `R`”。
* **递归读者**，顾名思义，是允许在同一锁实例的另一个读者的临界区内获取的锁，换句话说，允许一个锁实例嵌套读侧的临界区。
* 而 **非递归读者** 如果试图在同一锁实例的另一个读者的临界区内获取，则会导致自死锁。
* 递归读者和非递归读者之间的区别在于：递归读者只会被写锁 *持有者（holder）* 阻塞，而非递归者可能会被写锁 *等待者（waiter）* 阻塞。
* 考虑以下示例：
```c
TASK A:                 TASK B:

read_lock(X);
                        write_lock(X);
read_lock_2(X);
```
* 任务 A 首先通过 `read_lock()` 获取 `X` 上的读者（无论是递归还是非递归）。当任务 B 尝试获取 `X` 上的写者时，它将阻塞并成为 `X` 上 *写者等待者*。
  * 现在，如果 `read_lock_2()` 是 *递归读者*，任务 A 将会继续往前走，因为 *写者等待者* 不会阻塞 *递归读者*，并且不会出现死锁。
  * 但是，如果 `read_lock_2()` 是 *非递归读者*，它将被 *写者等待者* B 阻塞，并导致自死锁。

## 同一锁实例的读者/写者的阻塞条件：
* 阻塞条件矩阵，`Y` 表示 *行* 阻塞 *列*，`N` 表示其他情况。

. | W | r | R
--|---|---|---
W | Y | Y | Y
r | Y | Y | N
R | Y | Y | N

* (W: writers, r: non-recursive readers, R: recursive readers)

* 阻塞条件有四种：
  * 写者阻塞其他写者。
  * 读者阻塞写者。
  * 写者阻塞递归读者和非递归读者。
  * 读者（无论是否递归）不会阻塞其他递归读者，但可能会阻塞以递归方式获取的非递归读者（因为可能存在共存的 *写者等待者*）。
* 与 *非递归读锁* 不同，*递归读锁* 只会被当前 *写锁持有者*（而非 *写锁等待者*）阻塞，例如：
```c
TASK A:                 TASK B:

read_lock(X);
                        write_lock(X);
read_lock(X);
```
* 对于递归读锁来说，不是死锁，因为当任务 B 等待锁 `X` 时，第二个 `read_lock()` 不需要等待，因为它是一个递归读锁。
* 但是，如果 `read_lock()` 是非递归读锁，那么上述情况就是死锁，因为即使任务 B 中的 `write_lock()` 无法获取锁，但它可以阻塞任务 A 中的第二个 `read_lock()`。
* 注意，根据获取锁的操作（更具体地说，`lock_acquire()` 的‘`read`’参数的值），锁可以是写锁（排他锁）、非递归读锁（非递归共享锁）或递归读锁（递归共享锁）。
  * 换句话说，单个锁实例根据获取函数的不同，有三种获取类型：排他、非递归读和递归读。
* 为简洁起见，我们将 *写锁* 和 *非递归读锁* 称为 **“非递归”锁**，将 *递归读锁* 称为 **“递归”锁**。
* 递归锁不会相互阻塞，而非递归锁会相互阻塞（即使是两个 *非递归读锁* 也是如此）。非递归锁可以阻塞相应的递归锁，反之亦然。
* 涉及递归锁的死锁例子如下：
```c
TASK A:                 TASK B:

read_lock(X);
                        read_lock(Y);
write_lock(Y);
                        write_lock(X);
```
* 任务 A 正在等待任务 B `read_unlock() Y` ，而任务 B 正在等待任务 A `read_unlock() X`。
  * 译注：任务 A 获取了递归锁 `read_lock(X)` 导致任务 B 获取非递归锁 `write_lock(X)` 阻塞；任务 B 获取了递归锁 `read_lock(Y)` 导致任务 A 获取非递归锁 `write_lock(Y)` 阻塞

## 依赖类型和强依赖路径：
* 锁依赖关系记录了一对锁的获取顺序，由于锁有 3 种类型，因此理论上有 9 种锁依赖关系，但我们可以证明 4 种锁依赖关系足以进行死锁检测。
* 对于每个锁依赖关系：
```c
L1 -> L2
```
* 这意味着 lockdep 在运行时看到 `L1` 在 `L2` 被持有之前被持有。
* 在死锁检测中，我们关心的是 `L1` 被持有时我们是否会在 `L2` 上被阻塞，换句话说，是否存在一个锁 `L3`，`L1` 阻塞 `L3`，而 `L2` 被 `L3` 阻塞。
* 所以我们只关心：
  1. `L1` 阻塞了什么
  2. 什么阻塞了 `L2`
* 因此，我们可以将 `L1` 的 *递归读者 `R`* 和 *非递归读者 `r`* 组合起来（因为它们阻塞了相同的类型）
  * 译注：即矩阵的最下面两行可以合并
* 我们可以将 `L2` 的 *写者 `W`* 和 *非递归读者 `r`* 组合起来（因为它们被相同的类型阻塞）。
  * 译注：即矩阵的第二、三列可以合并
* **译注**：简化后的矩阵（*行* 阻塞 *列*）：

.      | Wr (N) | R
-------|--------|---
W (E)  | Y      | Y
rR (S) | Y      | N

* 按照上述简化后组合，lockdep 图（graph）中存在 4 种类型的 **依赖边（dependency edges）**：
1. `-(ER)->`：
   * *独占写者* 与 *递归读者* 的依赖关系，“`X -(ER)-> Y`”表示 `X -> Y` 且 `X` 是写者而 `Y` 是递归读者。
2. `-(EN)->`：
   * *独占写者* 与 *非递归锁* 的依赖关系，“`X -(EN)-> Y`”表示 `X -> Y` 且 `X` 是写者而 `Y` 是写者或非递归读者。
3. `-(SR)->`：
   * *共享读者* 与 *递归读者* 的依赖关系，“`X -(SR)-> Y`”表示 `X -> Y` 且 `X` 是读者（无论是否递归）而 `Y` 是递归读者。
4. `-(SN)->`：
   * *共享读者* 与 *非递归锁* 的依赖关系，“`X -(SN)-> Y`”表示 `X -> Y` 且 `X` 是读者（无论是否递归）而 `Y` 是写者或非递归读者。
* 注意，给定两个锁，它们之间可能存在多个依赖关系，例如：
```c
TASK A:

read_lock(X);
write_lock(Y);
...

TASK B:

write_lock(X);
write_lock(Y);
```
* 在依赖图中，我们有 `X -(SN)-> Y` 和 `X -(EN)-> Y`。
* 我们使用 `-(xN)->` 来表示 `-(EN)->` 或 `-(SN)->` 边，`-(Ex)->`、`-(xR)->` 和 `-(Sx)->` 也类似
* “**路径**”是图中一系列相交的 *依赖关系边*。
* 我们将 **“强”路径** 定义为：没有两条相交的边（依赖关系）的路径，如 `-(xR)->` 和 `-(Sx)->`，“强”路径表示路径中每个依赖都具有强依赖关系。
  * 换句话说，“强”路径是一条通过 *锁依赖* 从一个锁走到另一个锁的路径，如果路径中有 `X -> Y -> Z`（其中 `X`、`Y`、`Z` 是锁），并且从 `X` 到 `Y` 的路径通过 `-(SR)->` 或 `-(ER)->` 依赖，则从 `Y` 到 `Z` 的路径不能通过 `-(SN)->` 或 `-(SR)->` 依赖。
  * 译注：即 `-(xR)->` 和 `-(Sx)->` 依赖对有两条相交的边，不构成 `X -> Y -> Z` 的强路径
* 我们将在下一节中看到为什么该路径被称为“强”。

## 递归读死锁检测：
* 我们现在证明两件事：
* **引理 1（Lemma 1）**：
  * **如果存在封闭的强路径（即强循环），那么就存在导致死锁的锁序列组合。即一个 *强循环（strong circle）* 足以检测死锁。**
* **引理 2（Lemma 2）**：
  * **如果没有封闭的强路径（即强循环），那么就不存在可能导致死锁的锁序列组合。即强循环对于死锁检测是必要的。**
* 通过这两个引理，我们可以轻松地说封闭的强路径对于死锁既是充分的也是必要的，因此封闭的强路径等同于死锁的可能性。
  * 由于封闭的强路径代表可能导致死锁的依赖链，因此我们称其为“强”，因为存在不会导致死锁的依赖循环。
* 充分性证明（引理 1）：
* 假设我们有一个强循环：
```c
L1 -> L2 ... -> Ln -> L1
```
* 意味着我们有依赖
```c
L1 -> L2
L2 -> L3
...
Ln-1 -> Ln
Ln -> L1
```
* 现在我们可以构造一个导致死锁的锁序列组合：
  * 首先，让我们让一个 CPU/任务在 `L1 -> L2` 中获得 `L1`，然后另一个 CPU/任务在 `L2 -> L3` 中获得 `L2`，依此类推。此后，`Lx -> Lx+1` 中的所有 `Lx` 都由不同的 CPU/任务持有。
  * 然后因为我们有 `L1 -> L2`，所以 `L1` 的持有者将在 `L1 -> L2` 中获得 `L2`，但是由于 `L2` 已被另一个 CPU/任务持有，而且 `L1 -> L2` 和 `L2 -> L3` 不是 `-(xR)->` 和 `-(Sx)->`（*强* 的定义），这意味着 `L1 -> L2` 中的 `L2` 是非递归锁（`N`，被任何人阻塞）或 `L2 -> L3` 中的 `L2` 是写者（`E`，阻塞任何人），因此 `L1` 的持有者无法获得 `L2`，它必须等待 `L2` 的持有者释放。
  * 此外，对于 `L2` 的持有者，我们可以得出类似的结论：它必须等待 `L3` 的持有者释放，依此类推。
  * 我们现在可以证明 `Lx` 的持有者必须等待 `Lx+1` 的持有者释放，并注意到 `Ln+1` 是 `L1`，因此我们有一个循环等待场景，没有人能够取得进展，因此陷入死锁。

* 引理 2 等价于：如果存在死锁场景，那么依赖图中必定存在强循环。
* 根据 Wikipedia[1]，如果存在死锁，那么必定存在循环等待场景，即有 `N` 个 CPU/任务，其中 CPU/任务 `P1` 正在等待 `P2` 持有的锁，而 `P2` 正在等待 `P3` 持有的锁，...，而 `Pn` 正在等待 `P1` 持有的锁。
* 我们将 `Px` 正在等待的锁命名为 `Lx`，因此由于 `P1` 正在等待 `L1` 并持有 `Ln`，因此依赖图中将有 `Ln -> L1`。类似地，依赖图中有 `L1 -> L2、L2 -> L3、...、Ln-1 -> Ln`，这意味着我们有一个循环：
```c
Ln -> L1 -> L2 -> ... -> Ln
```
* 现在我们来证明这个循环是强的：
  * 对于一个锁 `Lx`，`Px` 贡献依赖 `Lx-1 -> Lx`，而 `Px+1` 贡献依赖 `Lx -> Lx+1`，并且由于 `Px` 正在等待 `Px+1` 释放 `Lx`，因此不可能出现 `Px+1` 上的 `Lx` 是读者，而 `Px` 上的 `Lx` 是递归读者的情况，因为读者（`S`无论是否递归）都不会阻塞递归读者（`R`），因此 `Lx-1 -> Lx` 和 `Lx -> Lx+1` 不可能是一对 {`-(xR)->`,`-(Sx)->`}，并且对于环中的任何锁都是如此，因此，该环是强循环。

## References
* [Runtime locking correctness validator — The Linux Kernel documentation](https://www.kernel.org/doc/html/latest/locking/lockdep-design.html)
* [1]\: https://en.wikipedia.org/wiki/Deadlock
* [2]\: Shibu, K. (2009). Intro To Embedded Systems (1st ed.). Tata McGraw-Hill